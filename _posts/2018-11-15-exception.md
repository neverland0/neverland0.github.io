---
layout: item
title: 追踪C++中的异常
---

## 标准库异常
  这里我们讨论的是c++标准库中定义的异常类，标准库中的异常类通常是基于同一个基类*std::exception* 类。标准库异常不包含任何路径信息，虽然我们可以得到异常的类型和异常被抛出位置的相关信息，但我们对异常抛出的路径一无所知，而恰巧有时候我们希望能知道异常的抛出路径，因此下面会介绍一种方法。


## 异常被抛出时发生了什么

  首先我们要知道，异常打破了程序的正常执行流程，在正常的程序执行过程中，当发生函数调用时，调用的返回地址会被保存在一个栈帧中，此外保存在栈帧中的还有主调函数传给被调函数的参数，此时被调函数通过帧指针加上偏移量就可以得到参数和返回地址。

  ![stack](/img/stackframe.jpg)

  而异常的处理流程和正常函数调用正好相反，被称为**栈展开**（*unwind*）,实际上，异常并不是导致栈展开的唯一原因，*longjmp* 和线程终止操作也会导致栈展开,但在这里我们只讨论异常的情况。

  gcc实现的栈展开过程主要分为两个阶段：
  1. 搜索阶段。在搜索阶段会调用一个personality routine，并指定一个\_UA\_SEARCH\_PHASE标志来指明当前是搜索阶段，首先在当前函数中搜索，然后从栈中展开一个帧，到展开的栈帧对应的函数中继续搜索，直到personality routine处理成功（异常被捕获）或失败（异常不能被捕获），而搜索和判断的任务就是由personality routine来完成的。
  2. 如果在搜索阶段中异常没能被捕获，那么就会调用标准库中的terminate()方法终止进程，如果异常被捕获，那么就进入第二个阶段，清理阶段。在清理阶段，又一次重复调用personality routine，但是指定\_UA\_CLEANUP\_PHASE标志来指明当前是清理阶段，同样的，先清理当前函数，再从栈中展开一个帧，清理对应的函数，直到达到异常被捕获的位置，此时，会恢复寄存器的值，然后控制返回到接下来的用户代码中。
  
## 故技重施

  通过分析栈帧信息，可以得到当前的函数调用链，如果我们想追踪异常路径，这可能是一个好方法，但我们的问题在于，一旦栈展开结束，清理工作完成，栈帧信息就不复存在了，所以我们要在清理阶段之前获取栈帧信息。然而异常被抛出后直到栈展开结束，程序的控制权都不在用户代码中，除非我们能在标准库代码加入我们自己的代码，否则这个方法行不通。

  等一等，在[上一篇文章](https://neverland0.github.io/neverland0.github.io/2018/11/01/hook.html)中,我们介绍了一种在C++中实现“钩子函数”的技巧，正好适用于现在的需求，这可真是太巧了，所以我们要做的就是找到栈展开过程中某个函数的函数原型，而personality routine可能是一个不错的选择，但是对于每一帧，personality routine都会被调用，然而我们只想让我们的代码执行一次。

  那么选择哪一次呢？肯定要在清理阶段之前，那就选择搜索阶段的最后一次吧，当异常被捕获时，personality routine函数会返回\_URC\_HANDLER\_FOUND指明异常已经被捕获，可以进入下一阶段，所以我们需要为personality routine安装钩子函数，然后对personality routine的返回值进行判断，如果是\_URC\_HANDLER\_FOUND就调用我们的代码。gcc实现的personality routine原型如下：

```c++

_Unwind_Reason_Code
__gxx_personality_v0 (int version,
              _Unwind_Action actions,
              _Unwind_Exception_Class exception_class,
              struct _Unwind_Exception *ue_header,
              struct _Unwind_Context *context);

```

  

## 闪回前咒

  现在的问题只剩下我们自己的代码该怎么实现了，你现在可能想到搜索引擎或者问答社区输入一些类似"back trace"、"stack back"之类的关键字，然后你可能会看到一个叫做*backtrace()* 的函数，你只需要包含<execinfo.h>头文件，然后调用backtrace(void **buffer, int size)就能得到函数调用链上各个函数地址，或者调用backtrace_symbols(void *const *buffer, int size)，并将之前得到的buffer传给它，就能打印出符号的信息，这样看起来好像不错了，但能不能更进一步，比如说具体到函数中的某一行，然后你又发现一个叫做addr2line 的工具，可以对符号的地址得到在源码中的行数。进展很顺利，但可能还有一些其他问题，但不论怎样，你解决了这些问题，终于松了一口气。

  大部分情况下这确实是一个不错的方法，“比较”轻松的解决了问题，但实际上我想介绍的是一个第三方库，你可能已经不想再往下看了，确实，有点累了，那么我们下一篇文章再介绍这个库。
